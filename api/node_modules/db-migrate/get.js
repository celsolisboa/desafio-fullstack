exports.migrate = async (db, opt) => {
  await db.get('test', {
    columns: ['column1']
  });

  /**
   * columns can be aliased
   */
  await db.get('test', {
    columns: {
      column1: 'maxima'
    }
  });

  /**
   * We avoid tapping into complicated languages to define
   * the where clause. Instead you just use SQL or mongo schema
   * depending on the db you use. If you want to provide genericity we will
   * suggest using helper libraries like sql2mongo or vice versa. This allows
   * flexibility and avoids also the need to learn to many new things and
   * reinventing the weel just for a translation layer in this case.
   */
  await db.get('test', {
    columns: {
      column1: 'maxima',
      column2: 'something'
    },
    search: 'maxima >= 12'
  });

  /**
   * However, the most simple operation we will support upfront. Everything
   * else can use tooling. We will provide a plugin hook so this can be in
   * doubt tightly integrated into the migrations.
   */
  await db.get('test', {
    columns: {
      column1: 'maxima',
      column2: 'something'
    },
    search: {
      maxima: 15
    }
  });

  /**
   * when doing more then searching, you want to access it in query mode.
   * You will have to write the whole definition by hand. This guarantees
   * that we still understand what is happening (type of operation), but
   * gives ultimate flexibility.
   *
   * The table param is optional, when using for example SQL it will not be
   * needed, databases like mongodb will need it however, so it might be
   * recommended as a best practice to not omit it, depending on how ultimate
   * the decision of the db is yet.
   *
   * Adding LIMITS yourself is possible, but leave this to db-migrate in doubt.
   */
  await db.get('test', {
    query: 'DISTINCT value1 FROM test' // select will be forcefully prepended so we always know this will only get data
  });
};

exports._meta = {
  version: 2,
  DML: true
};
